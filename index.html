<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Minecraft 2D - NieskoÅ„czony Å›wiat</title>
<style>
  body { margin: 0; overflow: hidden; background: #87ceeb; }
  canvas { display: block; cursor: crosshair; }
  #hud {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.5);
    color: white;
    padding: 10px 14px;
    border-radius: 8px;
    font-family: monospace;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">ðŸ’¼ Ekwipunek: <span id="inventory">{} </span></div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const invText = document.getElementById("inventory");

// --- StaÅ‚e ---
const TILE_SIZE = 40;
const CHUNK_SIZE = 32; // szerokoÅ›Ä‡ jednego "chunka"
const WORLD_HEIGHT = 40;
const SEA_LEVEL = 20;
const CAMERA_MARGIN = 6;
const gravity = 0.5;

// --- Gracz ---
const player = { x: 0, y: 0, w: 0.8, h: 1.8, vx: 0, vy: 0, onGround: false };
const moveSpeed = 0.3;
const jumpPower = 10;
const keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

// --- Ekwipunek ---
const inventory = { dirt: 0, stone: 0, grass: 0 };
function updateInventoryHUD() {
  invText.textContent = JSON.stringify(inventory);
}
updateInventoryHUD();

// --- Generator mapy (prosty perlin-like) ---
function pseudoNoise(x) {
  return Math.sin(x * 0.1) * 3 + Math.sin(x * 0.03) * 7;
}

function generateChunk(chunkX) {
  const chunk = [];
  for (let y = 0; y < WORLD_HEIGHT; y++) {
    chunk[y] = [];
    for (let x = 0; x < CHUNK_SIZE; x++) {
      const worldX = chunkX * CHUNK_SIZE + x;
      const height = SEA_LEVEL + Math.floor(pseudoNoise(worldX));
      if (y > height) chunk[y][x] = "stone";
      else if (y === height) chunk[y][x] = "grass";
      else if (y > height - 3) chunk[y][x] = "dirt";
      else chunk[y][x] = null;
    }
  }
  return chunk;
}

// --- PamiÄ™Ä‡ Å›wiata ---
const chunks = new Map();
function getChunk(cx) {
  if (!chunks.has(cx)) chunks.set(cx, generateChunk(cx));
  return chunks.get(cx);
}

function getBlock(wx, wy) {
  const cx = Math.floor(wx / CHUNK_SIZE);
  const lx = ((wx % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
  if (wy < 0 || wy >= WORLD_HEIGHT) return null;
  const chunk = getChunk(cx);
  return chunk[wy][lx];
}

function setBlock(wx, wy, type) {
  const cx = Math.floor(wx / CHUNK_SIZE);
  const lx = ((wx % CHUNK_SIZE) + CHUNK_SIZE) % CHUNK_SIZE;
  if (wy < 0 || wy >= WORLD_HEIGHT) return;
  const chunk = getChunk(cx);
  chunk[wy][lx] = type;
}

// --- Kamera ---
const camera = { x: 0, y: 0 };

// --- Kolizje ---
function collide() {
  player.onGround = false;
  player.vy += gravity;
  player.y += player.vy * 0.1;

  // pionowo
  if (getBlock(Math.floor(player.x), Math.floor(player.y + player.h))) {
    player.y = Math.floor(player.y + player.h) - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  // poziomo
  player.x += player.vx * 0.1;
  if (getBlock(Math.floor(player.x), Math.floor(player.y)) || getBlock(Math.floor(player.x), Math.floor(player.y + player.h * 0.5))) {
    player.x -= player.vx * 0.1;
    player.vx = 0;
  }
}

// --- Ruch gracza ---
function update() {
  if (keys["KeyA"] || keys["ArrowLeft"]) player.vx = -moveSpeed;
  else if (keys["KeyD"] || keys["ArrowRight"]) player.vx = moveSpeed;
  else player.vx = 0;

  if ((keys["Space"] || keys["ArrowUp"]) && player.onGround) {
    player.vy = -jumpPower;
    player.onGround = false;
  }

  collide();

  camera.x = player.x * TILE_SIZE - canvas.width / 2 + (player.w * TILE_SIZE) / 2;
  camera.y = player.y * TILE_SIZE - canvas.height / 2;
}

// --- Rysowanie blokÃ³w ---
function drawBlock(x, y, type) {
  if (!type) return;
  let color = "#654321";
  if (type === "grass") color = "#00aa00";
  if (type === "stone") color = "#777777";
  const px = x * TILE_SIZE - camera.x;
  const py = y * TILE_SIZE - camera.y;
  ctx.fillStyle = color;
  ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
  ctx.strokeStyle = "#00000022";
  ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
}

// --- Niszcz i stawiaj ---
canvas.addEventListener("mousedown", e => {
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left + camera.x) / TILE_SIZE;
  const my = (e.clientY - rect.top + camera.y) / TILE_SIZE;
  const wx = Math.floor(mx);
  const wy = Math.floor(my);

  if (e.button === 0) { // niszcz
    const block = getBlock(wx, wy);
    if (block) {
      inventory[block] = (inventory[block] || 0) + 1;
      setBlock(wx, wy, null);
      updateInventoryHUD();
    }
  }

  if (e.button === 2) { // stawiaj
    if (!getBlock(wx, wy)) {
      let typeToPlace = null;
      if (inventory.dirt > 0) typeToPlace = "dirt";
      else if (inventory.stone > 0) typeToPlace = "stone";
      else if (inventory.grass > 0) typeToPlace = "grass";
      if (typeToPlace) {
        setBlock(wx, wy, typeToPlace);
        inventory[typeToPlace]--;
        updateInventoryHUD();
      }
    }
  }
});
canvas.addEventListener("contextmenu", e => e.preventDefault());

// --- Rysowanie Å›wiata ---
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "#87ceeb";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const startX = Math.floor(camera.x / TILE_SIZE) - CAMERA_MARGIN;
  const endX = Math.floor((camera.x + canvas.width) / TILE_SIZE) + CAMERA_MARGIN;

  for (let y = 0; y < WORLD_HEIGHT; y++) {
    for (let wx = startX; wx <= endX; wx++) {
      const type = getBlock(wx, y);
      if (type) drawBlock(wx, y, type);
    }
  }

  // gracz
  const px = player.x * TILE_SIZE - camera.x;
  const py = player.y * TILE_SIZE - camera.y;
  ctx.fillStyle = "#ffcc00";
  ctx.fillRect(px, py, player.w * TILE_SIZE, player.h * TILE_SIZE);
}

// --- PÄ™tla gry ---
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

// --- Start ---
player.y = SEA_LEVEL - 5;
player.x = 0;
</script>
</body>
</html>
